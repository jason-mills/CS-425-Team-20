# Open3d imports
import open3d as o3d
import open3d.visualization.gui as gui
import open3d.visualization.rendering as rendering

# Imports from local files
from Structs import PointCloudStruct
from Structs import MeshStruct
from Structs import CircularArray

# Imports for utility
import numpy as np
import copy

# Getting screen dimensions from system
from win32api import GetSystemMetrics

class Editor():
    # Editor constructor
    def __init__(self, cloud_structs, output_directory_path, output_file_base_name, output_file_extension, run_interactive_mode):
        # True of false for running interactive/editor mode
        self.run_interactive_mode = run_interactive_mode

        # Metadata storage and parameters
        self.metadata = []
        self.fitness_scores = []

        # Define output file directory and output base name
        self.output_directory_path = output_directory_path
        self.output_file_base_name = output_file_base_name
        self.output_file_extension = output_file_extension

        # Give object cloud structs and cloud index for state management
        self.cloud_structs = copy.deepcopy(cloud_structs)
        self.backup_structs = copy.deepcopy(cloud_structs)

        # Create a total cloud and total down sample cloud for point cloud merging
        self.total_cloud = o3d.geometry.PointCloud()
        self.down_sample_total = o3d.geometry.PointCloud()

        # Give object a mesh object to work with
        self.mesh = o3d.geometry.TriangleMesh()
        self.mesh_material_record = rendering.MaterialRecord()
        self.mesh_material_record.shader = "defaultLit"

        # Last transformation that was generated by ICP, start with identity matrix for adding base points
        self.transformation = np.identity(4)

        # Code to run if the code is not being run in interactive mode
        if not run_interactive_mode:
            self.multiway_registration_merge()
            self.voxel_grid_down_sample()
            self.make_alpha_mesh()
            self.smooth_mesh()
            self.write_point_cloud_file()
            self.write_mesh_file()
            return

        # Load in circular array that contains structs for meshes and clouds
        self.geometries = self.initialize_circular_array(cloud_structs)
        self.circular_array_index = 1

        # keep track of current geometry name and lable so that updating the visualizer is possible
        self.current_geometry_name = ""
        self.current_3d_label = None

        # Keep track of what mode is being used for editing
        self.merging_method = "point to plane"
        self.meshing_method = "alpha"

        # Initialize the gui
        self.initialize_gui(cloud_structs)

        # Give the gui something to load with
        self.update_visualizer(self.geometries[1].geometry, self.geometries[1].name)

        return
    
    # Initialize a circular array for use in moving through geometries in the scene viewer
    def initialize_circular_array(self, cloud_structs):
        geometries = []

        geometries.append(PointCloudStruct("Total Cloud", None, None, None, None))

        for cloud_struct in cloud_structs:
            geometries.append(cloud_struct)

        geometries.append(MeshStruct("Mesh", None))

        circular_array = CircularArray(np.asarray(geometries))

        return circular_array

    # Initialize the gui
    def initialize_gui(self, cloud_structs):
        # Numbers that are useful to track for initilization
        self.initial_screen_width = int(GetSystemMetrics(0) * 0.75)
        self.initial_screen_heigth = int(GetSystemMetrics(1) * 0.75)

        # Create window, declare function for resizing widgets, and set keys for editing
        self.window = gui.Application.instance.create_window("C3P0", self.initial_screen_width, self.initial_screen_heigth)
        self.window.set_on_layout(self.on_layout)
        self.window.set_on_key(self.key_callbacks)
        self.em = self.window.theme.font_size

        # Call functions that add editor and scene widgets to the window
        self.initialize_editor()
        self.initialize_scene_widget(cloud_structs)

        return
    
    # Initialize the editor with desire buttons/functions
    def initialize_editor(self):
        self.layout = gui.Vert(2 * self.em, gui.Margins(self.em * 2, 2 * self.em, 2 * self.em, 2 * self.em))
        self.layout.frame = gui.Rect(0, self.window.content_rect.y, self.initial_screen_width * 0.25, self.window.content_rect.height)

        # START ICP GUI ELEMENTS
        merging_container_label = gui.Label("Point Cloud Merging Method: ")

        merging_method_selection = gui.RadioButton(gui.RadioButton.VERT)
        self.merging_methods = ["point to plane", "point to point", "color point to point"]
        merging_method_selection.set_items(["Point to Plane", "Point to Point", "Color Point to Point"])
        merging_method_selection.set_on_selection_changed(self.merging_method_selection)

        multiway_merge_button = gui.Button("Mulitway Merge")
        multiway_merge_button.set_on_clicked(self.multiway_registration_merge)

        merge_button = gui.Button("Merge Using Selection")
        merge_button.set_on_clicked(self.merge_next_cloud)

        add_merge_button = gui.Button("Add Merge to Total")
        add_merge_button.set_on_clicked(self.add_transformed_cloud)

        skip_merge_button = gui.Button("Skip Cloud")
        skip_merge_button.set_on_clicked(self.send_cloud_to_back)

        merging_method_container = gui.Vert(self.em, gui.Margins(0, 0, 0, 0))
        merging_method_container.add_child(merging_container_label)
        merging_method_container.add_child(multiway_merge_button)
        merging_method_container.add_child(merging_method_selection)
        merging_method_container.add_child(merge_button)
        merging_method_container.add_child(add_merge_button)
        merging_method_container.add_child(skip_merge_button)
        # END ICP GUI ELEMENTS
        
        # START MESH GUI ELEMENTS
        mesh_container_label = gui.Label("Meshing Method: ")

        meshing_method_selection = gui.RadioButton(gui.RadioButton.VERT)
        self.meshing_methods = ["alpha", "ball pivoting", "convex hull", "poisson"]
        meshing_method_selection.set_items(["Alpha", "Ball Pivoting", "Convex Hull", "Poisson"])
        meshing_method_selection.set_on_selection_changed(self.meshing_method_selection)

        mesh_button = gui.Button("Make Mesh")
        mesh_button.set_on_clicked(self.make_mesh)

        smooth_mesh_button = gui.Button("Smooth Mesh")
        smooth_mesh_button.set_on_clicked(self.smooth_mesh)

        meshing_container = gui.Vert(self.em, gui.Margins(0, 0, 0, 0))
        meshing_container.add_child(mesh_container_label)
        meshing_container.add_child(meshing_method_selection)
        meshing_container.add_child(mesh_button)
        meshing_container.add_child(smooth_mesh_button)
        # END MESH GUI ELEMENTS

        # START PREVIOUS NEXT GEOMETRIES ELEMENTS
        previous_next_label = gui.Label("Viewer Control: ")
        next_button = gui.Button("Next")
        next_button.set_on_clicked(self.view_next_cloud)
        
        previous_buttion = gui.Button("Previous")
        previous_buttion.set_on_clicked(self.view_previous_cloud)

        previous_next_container = gui.Vert(0.5 * self.em, gui.Margins(0, 0, 0 ,0))
        previous_next_container.add_child(previous_next_label)
        previous_next_container.add_child(previous_buttion)
        previous_next_container.add_child(next_button)
        # END PREVIOUS NEXT GEOMETRIES ELEMENTS

        # START SAVE GUI ELEMENTS
        saving_container_label = gui.Label("Save Options: ")

        file_extension_selection = gui.RadioButton(gui.RadioButton.VERT)
        self.file_extensions = [".stl", ".ply", ".obj", ".off", ".gltf"]
        file_extension_selection.set_items(self.file_extensions)
        file_extension_selection.set_on_selection_changed(self.file_extension_selection)

        save_cloud_button = gui.Button("Save Point Cloud")
        save_cloud_button.set_on_clicked(self.write_point_cloud_file)

        save_mesh_button = gui.Button("Save Mesh")
        save_mesh_button.set_on_clicked(self.write_mesh_file)

        saving_container = gui.Vert(self.em, gui.Margins(0, 0, 0, 0))
        saving_container.add_child(saving_container_label)
        saving_container.add_child(save_cloud_button)
        saving_container.add_child(save_mesh_button)
        saving_container.add_child(file_extension_selection)
        # END SAVE GUI ELEMENTS

        reset_button = gui.Button("Reset Clouds and Mesh")
        reset_button.set_on_clicked(self.revert_changes)

        # START OF PROGRESS BAR ELEMENTS
        self.progress_bar = gui.ProgressBar()
        self.progress_bar.visible = False
        # END OF PROGRESS BAR ELEMENTS

        # START OF DOWN SAMPLE GUI ELEMENTS
        down_sample_container = gui.Vert(self.em, gui.Margins(0, 0, 0, 0))

        voxel_grid_down_sample_button = gui.Button("Voxel Grid Downsample")
        voxel_grid_down_sample_button.set_on_clicked(self.voxel_grid_down_sample)

        voxel_down_sample_button = gui.Button("Voxel Downsample")
        voxel_down_sample_button.set_on_clicked(self.voxel_down_sample)

        down_sample_container.add_child(voxel_grid_down_sample_button)
        down_sample_container.add_child(voxel_down_sample_button)
        # END OF DOWN SAMPLE GUI ELEMENTS

        # Add gui elements to layout and then the layout to the window
        self.layout.add_child(self.progress_bar)
        self.layout.add_child(merging_method_container)
        self.layout.add_child(down_sample_container)
        self.layout.add_child(meshing_container)
        self.layout.add_child(saving_container)
        self.layout.add_child(reset_button)
        self.layout.add_child(previous_next_container)

        self.window.add_child(self.layout)

        return

    def merging_method_selection(self, new_index):
        self.merging_method = self.merging_methods[new_index]

        return

    def meshing_method_selection(self, new_index):
        self.meshing_method = self.meshing_methods[new_index]

        return
    
    def file_extension_selection(self, new_index):
        self.output_file_extension = self.file_extensions[new_index]

        return

    # Initialize the scene widget with desired functionality and geometries
    def initialize_scene_widget(self, cloud_structs):
        self.scene_widget = gui.SceneWidget()
        self.scene_widget.enable_scene_caching(True)
        self.scene_widget.scene = rendering.Open3DScene(self.window.renderer)
        self.scene = self.scene_widget.scene
        self.scene.scene.enable_sun_light(True)
        # [237/255,213/255,158/255]
        self.scene.scene.set_sun_light([0, 0, 0], [1, 1, 1], 1)
        self.view = self.scene.view
        self.view.set_shadowing(True, rendering.View.ShadowType.PCF)
        self.view.set_post_processing(True)
        # self.view.set_ambient_occlusion(True)

        self.scene_widget.set_on_key(self.key_callbacks)
        self.scene_widget.frame = gui.Rect(self.initial_screen_width * 0.25, self.window.content_rect.y, self.initial_screen_width, self.window.content_rect.height)

        self.add_all_geometry(cloud_structs)

        self.scene_widget.scene.set_background([0.5, 0.5, 0.5, 1])

        self.window.add_child(self.scene_widget)

        return

    # Define how the layout should change when the window is resized
    def on_layout(self, context):
        self.layout.frame = gui.Rect(0, self.window.content_rect.y, self.window.content_rect.get_right() * 0.25, self.window.content_rect.height)
        self.scene_widget.frame = gui.Rect(self.window.content_rect.get_right() * 0.25, self.window.content_rect.y, self.window.content_rect.get_right(), self.window.content_rect.height)

        return
    
    # Add all of the geometry into the scene widget
    def add_all_geometry(self, cloud_structs):
        material = rendering.MaterialRecord()
        # material.shader = "defaultLit"

        self.scene.add_geometry("Merge Result", self.total_cloud, material)

        self.scene.add_geometry("Total Cloud", self.total_cloud, material)
        self.scene.show_geometry("Total Cloud", False)

        for cloud_struct in cloud_structs:
            cloud_struct.cloud
            self.scene.add_geometry(cloud_struct.name, cloud_struct.cloud, material)
            self.scene.show_geometry(cloud_struct.name, False)

        self.scene.add_geometry("Mesh", self.mesh, material)
        self.scene.show_geometry("Mesh", False)

        return

    # Remove all geometry in the scene widget - used for reverting changes
    def remove_all_geometry(self, cloud_structs):
        self.scene.remove_geometry("Merge Result")

        self.scene.remove_geometry("Total Cloud")

        for cloud_struct in cloud_structs:
            self.scene.remove_geometry(cloud_struct.name)

        self.scene.remove_geometry("Mesh")

        return

    # Set the key callbacks that can be used instead of gui buttons
    def key_callbacks(self, context):
        if context.type == gui.KeyEvent.UP:
            if context.key == gui.KeyName.RIGHT: # right arrow key
                self.view_next_cloud()

            elif context.key == gui.KeyName.LEFT: #left arrow key
                self.view_previous_cloud()

            elif context.key == gui.KeyName.S:
                self.send_cloud_to_back()

            elif context.key in (267, 334): #insert and keypad plus
                self.merge_next_cloud()

            elif context.key in (gui.KeyName.ENTER, 257, 335): #enter and keypad enter
                self.add_transformed_cloud()

            elif context.key in (48, 321): # keyboard and keypad 0
                self.merging_method = "point to plane"

            elif context.key in (49, 322): # keyboard and keypad 1
                self.merging_method = "point to point"

            elif context.key in (50, 323): # keyboard and keypad 2
                self.merging_method = "color point to point"

            elif context.key == gui.KeyName.R:
                self.revert_changes()

        return True

    # clear changes to the cloud
    def revert_changes(self):
        self.metadata = []
        self.fitness_scores = []

        self.cloud_structs = copy.deepcopy(self.backup_structs)
        self.current_cloud_index = 1        

        self.total_cloud.clear()
        self.down_sample_total.clear()
        self.mesh.clear()

        if not self.current_3d_label == None:
            self.scene_widget.remove_3d_label(self.current_3d_label)

        if not self.current_geometry_name == "":
            self.scene.show_geometry(self.current_geometry_name, False)

        self.transformation = np.identity(4)
        
        self.current_geometry_name = ""
        self.current_3d_label = None

        self.remove_all_geometry(self.cloud_structs)
        self.add_all_geometry(self.cloud_structs)

        self.update_visualizer(self.geometries[1].geometry, self.geometries[1].name)

        return

    # increase the index and view the next cloud angle
    def view_next_cloud(self):
        if self.current_geometry_name == "Merge Result":
            self.update_visualizer(self.geometries[self.circular_array_index].geometry, self.geometries[self.circular_array_index].name)
        else:
            self.circular_array_index += 1
            self.update_visualizer(self.geometries[self.circular_array_index].geometry, self.geometries[self.circular_array_index].name)

        return

    # decrease the index and view the previous cloud angle
    def view_previous_cloud(self):
        if self.current_geometry_name == "Merge Result":
            self.update_visualizer(self.geometries[self.circular_array_index].geometry, self.geometries[self.circular_array_index].name)
        else:
            self.circular_array_index -= 1
            self.update_visualizer(self.geometries[self.circular_array_index].geometry, self.geometries[self.circular_array_index].name)

        return

    # cloud to be merged into is gray, cloud being merged in red
    def display_registration_result(self, source_cloud, target_cloud, transformation):
        source_cloud_copy = copy.deepcopy(source_cloud)
        target_cloud_copy = copy.deepcopy(target_cloud)

        source_cloud_copy.transform(transformation)
        source_cloud_copy.paint_uniform_color([0.54, 0, 0])
        target_cloud_copy.paint_uniform_color([0.5, 0.5, 0.5])

        combined_cloud = source_cloud_copy + target_cloud_copy

        self.scene.remove_geometry("Merge Result")
        self.scene.add_geometry("Merge Result", combined_cloud, rendering.MaterialRecord())
        self.update_visualizer(combined_cloud, "Merge Result")

        return

    # display outliers given cloud and indices of inliers
    def display_inlier_outlier(self, cloud, indices):
        cloud_copy = copy.deepcopy(cloud)

        inlier_cloud = cloud_copy.select_by_index(indices)
        outlier_cloud = cloud_copy.select_by_index(indices, invert=True)

        outlier_cloud.paint_uniform_color([1, 0, 0])
        inlier_cloud.paint_uniform_color([0.8, 0.8, 0.8])
        
        combined_cloud = inlier_cloud + outlier_cloud

        self.update_visualizer(combined_cloud, "Remove Outlier Result")
    
    # Update the visualizer widget to show the appropriate geometry with the name given to it
    def update_visualizer(self, geometry, name):
        label_position = [0, 0, 0]

        if geometry == None:
            self.scene.camera.look_at([0, 0, 0], [1, 1, 1], [0, 0, 1])
        else:
            bounding_box = geometry.get_axis_aligned_bounding_box()
            bounding_box_corners = np.asarray(bounding_box.get_box_points())
            label_position = bounding_box_corners[5]
            self.scene_widget.setup_camera(60, bounding_box, bounding_box.get_center())

        if not self.current_3d_label == None:
            self.scene_widget.remove_3d_label(self.current_3d_label)

        if not self.current_geometry_name == "":
            self.scene.show_geometry(self.current_geometry_name, False)

        self.current_3d_label = self.scene_widget.add_3d_label(label_position, name)
        self.current_geometry_name = name
        self.scene.show_geometry(name, True)
        
        return

    # add a cloud with the last calculated transformation
    def add_transformed_cloud(self):
        if not self.get_cloud_struct_len() > 0:
            self.window.show_message_box("Dialog box", "No more point clouds to add")
            return
        
        print("Adding: " + self.cloud_structs[0].name)

        self.total_cloud += self.cloud_structs[0].cloud.transform(self.transformation)
        self.down_sample_total += self.cloud_structs[0].downsampled_cloud.transform(self.transformation)

        self.cloud_structs.pop(0)

        if self.run_interactive_mode:
            self.scene.remove_geometry("Total Cloud")
            self.scene.add_geometry("Total Cloud", self.total_cloud, rendering.MaterialRecord())
            self.update_visualizer(self.total_cloud, "Total Cloud")

        return

    # move the cloud being merged to the end of the cloud structs
    def send_cloud_to_back(self):
        if not self.get_cloud_struct_len() > 0:
            return
        
        self.cloud_structs.append(self.cloud_structs[0])
        self.cloud_structs.pop(0)

        return

    # perform multiway registration on the given point clouds and update the visualizer accordingly
    def multiway_registration_merge(self):
        if not self.get_cloud_struct_len() > 0:
            return
        
        pose_graph = self.full_registration()

        option = o3d.pipelines.registration.GlobalOptimizationOption(max_correspondence_distance = self.cloud_structs[0].voxel_size,
                                                                     edge_prune_threshold = 0.25,
                                                                     reference_node = 0)
        
        o3d.pipelines.registration.global_optimization(pose_graph,
                                                       o3d.pipelines.registration.GlobalOptimizationLevenbergMarquardt(),
                                                       o3d.pipelines.registration.GlobalOptimizationConvergenceCriteria(),
                                                       option)

        for i in range(self.get_cloud_struct_len()):
            self.transformation = pose_graph.nodes[i].pose
            self.add_transformed_cloud()

        if self.run_interactive_mode:
            self.scene.remove_geometry("Total Cloud")
            self.scene.add_geometry("Total Cloud", self.total_cloud, rendering.MaterialRecord())
            self.update_visualizer(self.total_cloud, "Total Cloud")

        return

    # make the pose graph for the point clouds using pairwise_registration
    def full_registration(self):
        pose_graph = o3d.pipelines.registration.PoseGraph()
        odometry = np.identity(4)
        pose_graph.nodes.append(o3d.pipelines.registration.PoseGraphNode(odometry))
        
        cloud_struct_length = self.get_cloud_struct_len()
        for i in range(cloud_struct_length):
            for j in range(i + 1, cloud_struct_length):
                transformation, information_matrix = self.pairwise_registration(self.cloud_structs[i],
                                                            self.cloud_structs[j],
                                                            self.cloud_structs[i].voxel_size)
                
                if j == i + 1:
                    odometry = np.dot(transformation, odometry)
                    pose_graph.nodes.append(o3d.pipelines.registration.PoseGraphNode(np.linalg.inv(odometry)))
                    pose_graph.edges.append(o3d.pipelines.registration.PoseGraphEdge(i, 
                                                                                    j, 
                                                                                    transformation, 
                                                                                    information_matrix, 
                                                                                    uncertain = False))
                
                else:
                    pose_graph.edges.append(o3d.pipelines.registration.PoseGraphEdge(i,
                                                                                    j,
                                                                                    transformation,
                                                                                    information_matrix,
                                                                                    uncertain = True))                                               

        return pose_graph
    
    # apply a coarse point to plane merge and then a fine point to plane merge based on that coarse merge transformation
    def pairwise_registration(self, source, target, voxel_size):
        print("Applying pairwise registration with point to plane icp to: " + source.name + " and " + target.name)

        source.downsampled_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=voxel_size * 2, max_nn = 30))
        target.downsampled_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=voxel_size * 2, max_nn = 30))
   
        coarse_transformation = self.execute_distance_point_to_plane_refinement(source.downsampled_cloud,
                                                                       target.downsampled_cloud,
                                                                       voxel_size * 15,
                                                                       np.identity(4))
        
        fine_transformation = self.execute_distance_point_to_plane_refinement(source.downsampled_cloud,
                                                                     target.downsampled_cloud,
                                                                     voxel_size * 1.5,
                                                                     coarse_transformation)
   
        

        information_matrix = o3d.pipelines.registration.get_information_matrix_from_point_clouds(source.downsampled_cloud,
                                                                                                 target.downsampled_cloud,
                                                                                                 voxel_size * 1.5,
                                                                                                 fine_transformation)

        return fine_transformation, information_matrix

    # calculate the transformation for a point to plane merge with one point cloud onto the total cloud and display visualization
    def point_to_plane_merge(self):
            if len(self.total_cloud.points) == 0:
                self.add_transformed_cloud()

            if not self.get_cloud_struct_len() > 0:
                return

            source_down, sourceFpfh = self.preprocess_point_cloud(point_cloud=self.cloud_structs[0].downsampled_cloud, 
                                                                  voxel_size=self.cloud_structs[0].voxel_size)
            
            target_down, targetFpfh = self.preprocess_point_cloud(point_cloud=self.down_sample_total, 
                                                                  voxel_size=self.cloud_structs[0].voxel_size)
            
            
            ransac_result = self.execute_global_registration(source_down, 
                                                             target_down, 
                                                             sourceFpfh, 
                                                             targetFpfh, 
                                                             self.calculate_voxel_size(self.down_sample_total))

            self.cloud_structs[0].cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.cloud_structs[0].voxel_size * 2,
                                                                                              max_nn = 30))
            
            self.total_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.cloud_structs[0].voxel_size * 2,
                                                                                   max_nn =30 ))

            transformation = self.execute_point_to_plane_refinement(self.cloud_structs[0].cloud, 
                                                                    self.total_cloud, 
                                                                    self.cloud_structs[0].voxel_size * 1.5, 
                                                                    ransac_result.transformation)

            self.display_registration_result(self.cloud_structs[0].cloud, self.total_cloud, transformation)

            self.transformation = transformation

            return
    
    # calculate the transformation for a point to point merge with one point cloud onto the total cloud and display visualization
    def point_to_point_merge(self):
            if len(self.total_cloud.points) == 0:
                self.add_transformed_cloud()

            if not self.get_cloud_struct_len() > 0:
                return

            source_down, sourceFpfh = self.preprocess_point_cloud(point_cloud=self.cloud_structs[0].downsampled_cloud, 
                                                                  voxel_size=self.cloud_structs[0].voxel_size)
            
            target_down, targetFpfh = self.preprocess_point_cloud(point_cloud=self.down_sample_total, 
                                                                  voxel_size=self.cloud_structs[0].voxel_size)
            
            
            ransac_result = self.execute_global_registration(source_down, 
                                                             target_down, 
                                                             sourceFpfh, 
                                                             targetFpfh, 
                                                             self.calculate_voxel_size(self.down_sample_total))

            self.cloud_structs[0].cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.cloud_structs[0].voxel_size * 2,
                                                                                              max_nn=30))
            
            self.total_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.cloud_structs[0].voxel_size * 2,
                                                                                   max_nn=30))
            
            transformation = self.execute_point_to_point_refinement(self.cloud_structs[0].cloud, 
                                                                    self.total_cloud,
                                                                    self.cloud_structs[0].voxel_size * 1.5, 
                                                                    ransac_result.transformation)

            self.display_registration_result(self.cloud_structs[0].cloud, self.total_cloud, transformation)

            self.transformation = transformation

            return
    
    # calculate the transformation for a color point to point merge with one point cloud onto the total cloud and display visualization
    def color_point_to_point_merge(self):
            if len(self.total_cloud.points) == 0:
                self.add_transformed_cloud()

            if not self.get_cloud_struct_len() > 0:
                return

            if not self.cloud_structs[0].cloud.has_colors():
                self.window.show_message_box("Something", "This point cloud does not have color")
                return

            source_down, sourceFpfh = self.preprocess_point_cloud(point_cloud=self.cloud_structs[0].downsampled_cloud, 
                                                                  voxel_size=self.cloud_structs[0].voxel_size)
            
            target_down, targetFpfh = self.preprocess_point_cloud(point_cloud=self.down_sample_total, 
                                                                  voxel_size=self.cloud_structs[0].voxel_size)
            
            
            ransac_result = self.execute_global_registration(source_down, 
                                                       target_down, 
                                                       sourceFpfh, 
                                                       targetFpfh, 
                                                       self.calculate_voxel_size(self.down_sample_total))

            self.cloud_structs[0].cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.cloud_structs[0].voxel_size * 2,
                                                                                               max_nn=30))
            self.total_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.cloud_structs[0].voxel_size * 2,
                                                                                    max_nn=30))
            
            transformation = self.execute_color_point_to_point_refinement(self.cloud_structs[0].cloud, 
                                                                          self.total_cloud,
                                                                          self.cloud_structs[0].voxel_size * 1.5, 
                                                                          ransac_result.transformation)

            self.display_registration_result(self.cloud_structs[0].cloud, self.total_cloud, transformation)

            self.transformation = transformation

            return

    # estimate normals and compute 33 dimensional FPHP vector
    def preprocess_point_cloud(self, point_cloud, voxel_size):
        radius_normal = voxel_size * 2
        point_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normal, max_nn=30))
        radius_feature = voxel_size * 5
        pcd_fpfh = o3d.pipelines.registration.compute_fpfh_feature(point_cloud, o3d.geometry.KDTreeSearchParamHybrid(radius=radius_feature, max_nn=100))

        return point_cloud, pcd_fpfh

    # get a general transformation matrix to apply to align points
    def execute_global_registration(self, source_down, target_down, source_fpfh, target_fpfh, voxel_size):
        distance_threshold = voxel_size * 1.5

        registration_result = o3d.pipelines.registration.registration_ransac_based_on_feature_matching(source_down,
                                                                                                       target_down,
                                                                                                       source_fpfh, 
                                                                                                       target_fpfh, 
                                                                                                       True, 
                                                                                                       distance_threshold, 
                                                                                                       o3d.pipelines.registration.TransformationEstimationPointToPoint(False), 
                                                                                                       3, 
                                                                                                       [o3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength(0.9),
                                                                                                        o3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance(distance_threshold)], 
                                                                                                        o3d.pipelines.registration.RANSACConvergenceCriteria(100000, 0.999))
        
        return registration_result

    # use point to point refinement
    def execute_point_to_point_refinement(self, source, target, voxel_size, initial_transformation):
        registration_result = o3d.pipelines.registration.registration_icp(source, 
                                                                target, 
                                                                voxel_size * 1.5,
                                                                initial_transformation,
                                                                o3d.pipelines.registration.TransformationEstimationPointToPoint(),
                                                                o3d.pipelines.registration.ICPConvergenceCriteria(max_iteration=200))
        

        return registration_result.transformation

    # use point to plane refinement
    def execute_point_to_plane_refinement(self, source, target, voxel_size, initial_transformation):
        source.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=voxel_size*2,
                                                                    max_nn=30))
        
        target.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=voxel_size*2,
                                                                    max_nn=30))

        registration_result = o3d.pipelines.registration.registration_icp(source,
                                                                          target,
                                                                          voxel_size * 1.5,
                                                                          initial_transformation,
                                                                          o3d.pipelines.registration.TransformationEstimationPointToPlane())

        return registration_result.transformation

    def execute_distance_point_to_plane_refinement(self, source, target, distance, initial_transformation):
        registration_result = o3d.pipelines.registration.registration_icp(source,
                                                                          target,
                                                                          distance,
                                                                          initial_transformation,
                                                                          o3d.pipelines.registration.TransformationEstimationPointToPlane())
        
        self.fitness_scores.append(registration_result.fitness)

        return registration_result.transformation

    # use color point to point refinement
    def execute_color_point_to_point_refinement(self, source, target, voxel_size, initial_transformation):
        registration_result = o3d.pipelines.registration.registration_colored_icp(source,
                                                                                  target,
                                                                                  voxel_size * 0.05,
                                                                                  initial_transformation,
                                                                                  o3d.pipelines.registration.TransformationEstimationForColoredICP(),
                                                                                  o3d.pipelines.registration.ICPConvergenceCriteria(max_iteration=200))

        return registration_result.transformation

    # Merge the next point cloud that is available
    def merge_next_cloud(self):
        if(self.get_cloud_struct_len() == 0):
            self.window.show_message_box("Something", "No more point clouds to merge")
            return
        
        if self.merging_method == "point to plane":
            self.point_to_plane_merge()

        elif self.merging_method == "point to point":
            self.point_to_point_merge()

        elif self.merging_method == "color point to point":
            self.color_point_to_point_merge()
        
        return

    # use to make different meshes with different options
    def make_mesh(self):
        if self.meshing_method == "alpha":
            self.make_alpha_mesh()

        elif self.meshing_method == "ball pivoting":
            self.make_ball_pivoting_mesh()

        elif self.meshing_method == "convex hull":
            self.make_convex_hull_mesh()

        elif self.meshing_method == "poisson":
            self.make_poisson_mesh()

        return

    # Grid down sample the total dloud
    def voxel_down_sample(self):
        if len(self.total_cloud.points) == 0:
            return
        
        self.total_cloud = self.total_cloud.voxel_down_sample(self.calculate_voxel_size(self.total_cloud) * 3)

        if self.run_interactive_mode:
            self.scene.remove_geometry("Total Cloud")
            self.scene.add_geometry("Total Cloud", self.total_cloud, rendering.MaterialRecord())
            self.update_visualizer(self.total_cloud, "Total Cloud")
        return
    
    # Down sample the total cloud
    def voxel_grid_down_sample(self):
        if len(self.total_cloud.points) == 0:
            return
        
        voxel_grid = o3d.geometry.VoxelGrid.create_from_point_cloud(self.total_cloud, self.calculate_voxel_size(self.total_cloud) * 3)
        all_voxels = voxel_grid.get_voxels()
        all_centers = []
        all_colors = []

        for voxel in all_voxels:
            voxel_center = voxel_grid.get_voxel_center_coordinate(voxel.grid_index)
            all_centers.append(voxel_center)
            all_colors.append(voxel.color)

        self.total_cloud.points = o3d.utility.Vector3dVector(all_centers)
        self.total_cloud.colors = o3d.utility.Vector3dVector(all_colors)

        if self.run_interactive_mode:
            self.scene.remove_geometry("Total Cloud")
            self.scene.add_geometry("Total Cloud", self.total_cloud, rendering.MaterialRecord())
            self.update_visualizer(self.total_cloud, "Total Cloud")
        return

    # Make a mesh using alpha meshing method
    def make_alpha_mesh(self): 
        self.mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_alpha_shape(self.total_cloud, self.calculate_voxel_size(self.total_cloud) * 3)

        self.mesh.compute_vertex_normals()
        
        if self.run_interactive_mode:
            self.scene.remove_geometry("Mesh")
            self.scene.add_geometry("Mesh", self.mesh, self.mesh_material_record)
            self.update_visualizer(self.mesh, "Mesh")

        return

    # Make a mesh using ball pivoting method
    def make_ball_pivoting_mesh(self):
        if len(self.total_cloud.points) == 0:
            return

        self.total_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.calculate_voxel_size(self.total_cloud) * 2, max_nn = 30))
        self.total_cloud.orient_normals_consistent_tangent_plane(100)

        distances = self.total_cloud.compute_nearest_neighbor_distance()
        avg_dist = np.mean(distances)
        radius = 2 * avg_dist 

        self.mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_ball_pivoting(
            self.total_cloud,
            o3d.utility.DoubleVector([radius, radius * 2]))
        

        self.color_mesh([0.5, 0.5, 0.5])
        self.mesh.compute_vertex_normals()

        if self.run_interactive_mode:
            self.scene.remove_geometry("Mesh")
            self.scene.add_geometry("Mesh", self.mesh, self.mesh_material_record)
            self.update_visualizer(self.mesh, "Mesh")

        return
    
    # Make a mesh using convex hull method
    def make_convex_hull_mesh(self):
        if len(self.total_cloud.points) == 0:
            return

        self.total_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.calculate_voxel_size(self.total_cloud) * 2, max_nn = 30))
        self.total_cloud.orient_normals_consistent_tangent_plane(100)

        self.mesh = self.total_cloud.compute_convex_hull()[0]

        self.color_mesh([0.5, 0.5, 0.5])
        self.mesh.compute_vertex_normals()
        
        if self.run_interactive_mode:
            self.scene.remove_geometry("Mesh")
            self.scene.add_geometry("Mesh", self.mesh, self.mesh_material_record)
            self.update_visualizer(self.mesh, "Mesh")

        return

    # make a mesh using poisson method
    def make_poisson_mesh(self):
        if len(self.total_cloud.points) == 0:
            return

        self.total_cloud.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=self.calculate_voxel_size(self.total_cloud) * 2, max_nn = 30))
        self.total_cloud.orient_normals_consistent_tangent_plane(100)
        self.mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(self.total_cloud, depth=8, width=0, scale=1.1, linear_fit=False)[0]


        self.color_mesh([0.5, 0.5, 0.5])
        self.mesh.compute_vertex_normals()

        if self.run_interactive_mode:
            self.scene.remove_geometry("Mesh")
            self.scene.add_geometry("Mesh", self.mesh, self.mesh_material_record)
            self.update_visualizer(self.mesh, "Mesh")

        return

    # smooth the mesh using smiple filter
    def smooth_mesh(self):
        if len(self.mesh.vertices) == 0:
            return
        
        self.mesh = self.mesh.filter_smooth_simple(number_of_iterations=1)

        if self.run_interactive_mode:
            self.scene.remove_geometry("Mesh")
            self.scene.add_geometry("Mesh", self.mesh, self.mesh_material_record)
            self.update_visualizer(self.mesh, "Mesh")

        return

    # color the total point cloud a specific color
    def color_cloud(self, color):
        self.total_cloud.paint_uniform_color([color[0], color[1], color[2]])

        return

    # color the mesh a specific color
    def color_mesh(self, color):
        self.mesh.paint_uniform_color([color[0], color[1], color[2]])

        return

    # calculate a voxel size for a point cloud
    # this calculated voxel size can be used for icp
    def calculate_voxel_size(self, cloud):
        return round(max(cloud.get_max_bound() - cloud.get_min_bound()) * 0.01, 4)
    
    # Calculate the average fitness score
    def calculate_average_fitness(self):
        total = 0
        for score in self.fitness_scores:
            total += score
        
        return total/len(self.fitness_scores)

    # get length of cloud struct
    # this is me being lazy because I don't want to tyle len(self.cloud_structs) - oh no I just did it
    def get_cloud_struct_len(self):
        return len(self.cloud_structs)

    # write a point cloud file with a specific file extension
    def write_point_cloud_file(self):
        file_path = self.output_directory_path + "/" + self.output_file_base_name + ".xyz"
        o3d.io.write_point_cloud(file_path, self.total_cloud)

        return

    # write a mesh file 
    def write_mesh_file(self):
        file_path = self.output_directory_path + "/" + self.output_file_base_name + self.output_file_extension
        self.mesh.compute_vertex_normals()
        o3d.io.write_triangle_mesh(file_path, self.mesh)

        return